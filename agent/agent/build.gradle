plugins {
  id("ai.java-conventions")
  id("com.github.johnrengelman.shadow")
}

apply from: "$buildScriptsDir/publish.gradle"

configurations {
  shadowInclude {
    description "For marking dependencies that should be shaded into this project's artifact"
  }
}

processResources {

  dependsOn ":agent:instrumentation:shadowJar"

  from(zipTree(tasks.getByPath(":agent:instrumentation:shadowJar").archivePath)) {
    into "inst"
    rename '(^.*)\\.class$', '$1.classdata'
  }
}

jar {
  manifest {
    attributes(
      "Premain-Class": "com.microsoft.applicationinsights.agent.Agent",
      // Agent-Class is provided only for dynamic attach in the first line of main
      // there are many problematic edge cases around dynamic attach any later than that
      "Agent-Class": "com.microsoft.applicationinsights.agent.Agent",
      "Can-Redefine-Classes": true,
      "Can-Retransform-Classes": true,
    )
  }
  dependsOn shadowJar
  enabled = false
}

shadowJar {
  archiveClassifier.set("")
  mergeServiceFiles()

  exclude "**/module-info.class"
  exclude "META-INF/jandex.idx" // from caffeine
  exclude "META-INF/moshi.kotlin_module"

  // TEMPORARY until optimization lands upstream
  exclude "io/opentelemetry/api/common/AttributeKeyImpl.class"
  relocate "patched.io.opentelemetry.api.common.AttributeKeyImpl", "io.opentelemetry.javaagent.shaded.io.opentelemetry.api.common.AttributeKeyImpl"

  // Prevents conflict with other SLF4J instances. Important for premain.
  relocate "org.slf4j", "io.opentelemetry.javaagent.slf4j"
  // rewrite dependencies calling Logger.getLogger
  relocate "java.util.logging.Logger", "io.opentelemetry.javaagent.bootstrap.PatchLogger"

  // prevents conflict with library instrumentation
  relocate "io.opentelemetry.instrumentation.api", "io.opentelemetry.javaagent.shaded.instrumentation.api"

  // relocate OpenTelemetry API
  relocate "io.opentelemetry.api", "io.opentelemetry.javaagent.shaded.io.opentelemetry.api"
  relocate "io.opentelemetry.semconv", "io.opentelemetry.javaagent.shaded.io.opentelemetry.semconv"
  relocate "io.opentelemetry.spi", "io.opentelemetry.javaagent.shaded.io.opentelemetry.spi"
  relocate "io.opentelemetry.context", "io.opentelemetry.javaagent.shaded.io.opentelemetry.context"

  // ApplicationInsights shading
  exclude "META-INF/services/javax.servlet.ServletContainerInitializer"
  exclude "META-INF/proguard/**"

  def shadowPrefix = "com.microsoft.applicationinsights.agent.shadow"

  relocate "ch.qos.logback", "${shadowPrefix}.ch.qos.logback"
  relocate "com.squareup.moshi", "${shadowPrefix}.com.squareup.moshi"
  relocate "okio", "${shadowPrefix}.okio"

  relocate("logback.configurationFile", "applicationinsights.logback.configurationFile")
  relocate("logback.xml", "applicationinsights.logback.xml")
  relocate("logback.groovy", "applicationinsights.logback.groovy")
  // to prevent accidentally picking up from user's class path
  relocate("logback-test.xml", "applicationinsights.logback-test.xml")
  // to prevent accidentally picking up from user's class path

}

archivesBaseName = "applicationinsights-agent"

dependencies {
  implementation(project(":agent:agent-bootstrap"))
  implementation("io.opentelemetry.javaagent:opentelemetry-javaagent-bootstrap") {
    exclude group: "org.slf4j", module: "slf4j-simple"
  }
}

// region Publishing properties

projectPomName = "Microsoft Application Insights Java Agent"
projectPomDescription = "Microsoft Application Insights Java Agent"

whenPomConfigured = { p ->
  p.dependencies = []
}

// endregion Publishing properties


import java.util.jar.JarFile
import org.apache.tools.ant.taskdefs.condition.Os

task verifyAgentJarContents {
  dependsOn jar
  def jarContentsFile = file("$projectDir/jar_contents.regex")
  def jarContentsFileExists = jarContentsFile.exists()
  logger.info "${project.name} will ${jarContentsFileExists ? '' : 'not '}run '$name'"
  onlyIf {
    !(System.properties["skipWinNative"] ?: "false").toBoolean() && Os.isFamily(Os.FAMILY_WINDOWS) && jarContentsFileExists
  }
  Set expectedEntries = []
  // jar_contents.regex should have one pattern per line
  jarContentsFile.eachLine {
    expectedEntries << it
  }
  def logOutputDirectory = "$buildDir/reports/verifyAgentJar"
  def extraEntriesFilePath = "$logOutputDirectory/extraEntries.txt"
  def missingEntriesFilePath = "$logOutputDirectory/missingEntries.txt"
  def foundEntriesFilePath = "$logOutputDirectory/foundEntries.txt"
  def summaryFilePath = "$logOutputDirectory/summary.txt"
  doLast {
    def file = tasks.jar.archiveFile.get().asFile
    Set<String> extraEntries = []
    Set<String> foundEntries = []
    def acceptableEntry = { entry ->
      boolean totalResult = false;
      expectedEntries.each { pattern ->
        def result = entry.name.matches(pattern)
        if (result) {
          foundEntries << pattern
        }
        totalResult = result || totalResult
      }
      totalResult
    }

    LogLevel lvl = isBuildServer ? LogLevel.INFO : LogLevel.DEBUG
    new JarFile(file).withCloseable { jarfile ->
      logger.info "Verifying ${jarfile}"
      jarfile.entries().each {
        if (!acceptableEntry(it)) {
          logger.log(lvl, ">>>> UNEXPECTED ENTRY: ${it.name}")
          extraEntries << it.name
        } else {
          logger.log(lvl, "  >> ${it.name} VERIFIED")
        }
      }
    }

    def error = ""
    Set missingEntries = expectedEntries - foundEntries

    // always cleanup existing files
    [foundEntriesFilePath, missingEntriesFilePath, extraEntriesFilePath, summaryFilePath].each { filename ->
      File f = new File(filename)
      if (f.exists()) {
        f.delete()
      }
    }

    ext.writeEntriesToFile = { filename, entries ->
      File f = new File(filename)
      if (!f.parentFile.exists()) {
        f.parentFile.mkdirs();
      }
      f.withWriter { w ->
        entries.each { e -> w.println e }
      }
    }
    writeEntriesToFile(foundEntriesFilePath, foundEntries)
    if (!missingEntries.empty) {
      writeEntriesToFile(missingEntriesFilePath, missingEntries)
      if (isBuildServer) {
        missingEntries.each {
          logger.log(lvl, ">>>> MISSING ENTRY: $it")
        }
      }
      error += "  ${missingEntries.size()} missing entries. See list in $missingEntriesFilePath\n"
    }
    if (!extraEntries.empty) {
      writeEntriesToFile(extraEntriesFilePath, extraEntries)
      error += " ${extraEntries.size()} unexpected entries. See list in $extraEntriesFilePath\n"
    }
    new File(summaryFilePath).withWriter { w ->
      w.println "${missingEntries.size()} missing entries (expected ${expectedEntries.size()}."
      w.println "${extraEntries.size()} extra entries."
    }
    if (!error.empty) {
      throw new RuntimeException("${file.name} has issues:\n$error")
    }
    logger.info "${file.name} verified successfully."
  }
}
tasks.assemble.dependsOn verifyAgentJarContents

/**
 * Creates tasks for setting up integration environments making local testing easier
 *
 * For each subfolder in /package, e.g. `xyz`, it creates a task `setupXyz`
 * This creates a folder in /build/setup/xyz which contains the package contents for that environment.
 *
 * Using File.separator here because the console output in indended to be copy/pasted.
 */
file("$projectDir/package").eachDir {
  def name = it.name
  def path = it.absoluteFile
  def targetDir = "$buildDir${File.separator}setup${File.separator}$name"
  def targetDirRelative = "${buildDir.name}${File.separator}setup${File.separator}$name"
  def taskName = "setup${name.capitalize()}"
  tasks.register(taskName, Copy) {
    group = "Local Dev Setup"
    description = "Copies agent jar and resource files into $targetDirRelative for use in testing."
    logger.info "Configuring $taskName: src=${path}, dest=$targetDir"
    from(path) {
      include "**/**"
    }
    def jarFiles = []
    from(tasks.jar.archiveFile.asFile.get().parent) {
      include "*.jar"
      eachFile { jf ->
        jarFiles << "$targetDir${File.separator}${jf.name}"
      }
    }
    into targetDir
    dependsOn assemble
    doLast {
      logger.quiet "Dev Setup for ${name.capitalize()}:\n"
      def agentArgs = jarFiles.collect {
        "  -javaagent:$it\n"
      }.join("  OR\n")
      logger.quiet agentArgs
    }
  }
}
